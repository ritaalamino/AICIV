<script>

	const mainContainer = new PIXI.Container();
	const optionContainer = new PIXI.Container();
	app.stage.addChild(container);

	const starTexture = PIXI.Texture.from('/sprites/star.png');

	let cameraZ = 0;
	let speed = 0;
	let warpSpeed = 0;

	const animationProps = {
		fov: 20,
		amount: 1000,
		stretch: 5,
		baseSize: 0.05,
		baseSpeed: 0.25,
	};

	const stars = [];
	for (let i = 0; i < animationProps.amount; i++) {
		const star = {
			sprite: new PIXI.Sprite(starTexture),
			z: 0,
			x: 0,
			y: 0,
		};
		star.sprite.anchor.x = 0.5;
		star.sprite.anchor.y = 0.7;
		randomizeStar(star, true);
		mainContainer.addChild(star.sprite);
		stars.push(star);
	}



	function randomizeStar(star, initial) {
		star.z = initial ? Math.random() * 2000 : cameraZ + Math.random() * 1000 + 2000;

		// Calculate star positions with radial random coordinate so no star hits the camera.
		const deg = Math.random() * Math.PI * 2;
		const distance = Math.random() * 50 + 1;
		star.x = Math.cos(deg) * distance;
		star.y = Math.sin(deg) * distance;
	}

	const logo = PIXI.Sprite.from('/img/logo.png');
	logo.anchor.set(0.5);
	logo.x = app.screen.width * 0.54;
	logo.y = app.screen.height * 0.10;
	mainContainer.addChild(logo);


	const logoTime = PIXI.Sprite.from('/img/logotime.svg');
	logoTime.anchor.set(0.5);
	logoTime.x = app.screen.width * 0.15;
	logoTime.y = app.screen.height * 0.88;
	mainContainer.addChild(logoTime);

	// BotÃµes
	let yButtons = app.screen.height * 0.40;
	let gap = 10;
	let stride = 50;

	const buttonsProps = [
		{ src: '/img/play.png', onClick: () => alert('fodac') },
		{ src: '/img/instructions.png', onClick: () => alert('asdasdasd') },
		{ src: '/img/credits.png', onClick: () => alert('asdasdasd') },
		{ src: '/img/settings.png', onClick: () => alert('asdasdasd') }
	];

	for (i = 0; i < buttonsProps.length; i++) {
		const button = buttonsProps[i];
		const temp_button = new Button(
			button.src,
			app.screen.width / 2,
			yButtons + gap * i + stride * i,
			0.5,
			button.onClick
		);
		mainContainer.addChild(temp_button.sprite);
	}

	const bgAudio = new sound('/sounds/bg-home2.mp3', true);
	let bgStarted = false;
	document.body.addEventListener("mousemove", function () {
		try {
			bgAudio.play()
		} catch {
		}
	});




	app.ticker.add((delta) => {
		// Simple easing. This should be changed to proper easing function when used for real.
		speed += (warpSpeed - speed) / 20;
		cameraZ += delta * 10 * (speed + animationProps.baseSpeed);
		for (let i = 0; i < animationProps.amount; i++) {
			const star = stars[i];
			if (star.z < cameraZ) randomizeStar(star);

			// Map star 3d position to 2d with really simple projection
			const z = star.z - cameraZ;
			star.sprite.x = star.x * (animationProps.fov / z) * app.renderer.screen.width + app.renderer.screen.width / 2;
			star.sprite.y = star.y * (animationProps.fov / z) * app.renderer.screen.width + app.renderer.screen.height / 2;

			// Calculate star scale & rotation.
			const dxCenter = star.sprite.x - app.renderer.screen.width / 2;
			const dyCenter = star.sprite.y - app.renderer.screen.height / 2;
			const distanceCenter = Math.sqrt(dxCenter * dxCenter + dyCenter * dyCenter);
			const distanceScale = Math.max(0, (2000 - z) / 2000);
			star.sprite.scale.x = distanceScale * animationProps.baseSize;
			// Star is looking towards center so that y axis is towards center.
			// Scale the star depending on how fast we are moving, what the stretchfactor is and depending on how far away it is from the center.
			star.sprite.scale.y = distanceScale * animationProps.baseSize + distanceScale * speed * animationProps.stretch * distanceCenter / app.renderer.screen.width;
			star.sprite.rotation = Math.atan2(dyCenter, dxCenter) + Math.PI / 2;
		}
	});





</script>